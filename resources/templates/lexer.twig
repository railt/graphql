{% include "partials/header.twig" %}
namespace Railt\SDL\Parser;

use Phplrt\Source\File;
use Phplrt\Lexer\Lexer as Runtime;
use Phplrt\Contracts\Lexer\TokenInterface;
use Phplrt\Contracts\Lexer\LexerInterface;
use Railt\SDL\Exception\SyntaxErrorException;
use Phplrt\Contracts\Source\ReadableInterface;
use Phplrt\Contracts\Lexer\Exception\LexerRuntimeExceptionInterface;

/**
 * This class provides GraphQL lexer.
 *
 * @see https://en.wikipedia.org/wiki/Lexical_analysis
 * @internal This class is generated by railt/parser, specifically by Railt\SDL\Parser\Generator
 */
final class Lexer implements LexerInterface
{
{% for name, pattern in tokens.default %}
    /**
     * @var string
     */
    public const {{ name | raw }} = {{ value(name) | raw }};

{% endfor %}
    /**
     * A GraphQL document is comprised of several kinds of indivisible
     * lexical tokens defined here in a lexical grammar by patterns
     * of source Unicode characters.
     *
     * Tokens are later used as terminal symbols in a GraphQL Document
     * syntactic grammars.
     *
     * @see https://graphql.github.io/graphql-spec/draft/#sec-Source-Text.Lexical-Tokens
     * @var string[]
     */
    private const GRAPHQL_LEXICAL_TOKENS = [
{% for name, pattern in tokens.default %}
        self::{{ name | raw }} => {{ value(pattern) | raw }},
{% endfor %}
    ];

    /**
     * Before and after every lexical token may be any amount of ignored tokens
     * including WhiteSpace and Comment. No ignored regions of a source document
     * are significant, however otherwise ignored source characters may appear
     * within a lexical token in a significant way, for example a StringValue
     * may contain white space characters and commas.
     *
     * @see https://graphql.github.io/graphql-spec/draft/#sec-Source-Text.Ignored-Tokens
     * @var string[]
     */
    private const GRAPHQL_IGNORED_TOKENS = [
{% for name in skip %}
        self::{{ name | raw }},
{% endfor %}
    ];

    /**
     * @var LexerInterface
     */
    private LexerInterface $lexer;

    /**
     * GraphQLLexer constructor.
     */
    public function __construct()
    {
        $this->lexer = new Runtime(self::GRAPHQL_LEXICAL_TOKENS, self::GRAPHQL_IGNORED_TOKENS);
    }

    /**
     * Returns a set of token objects from the passed source.
     *
     * @param string|resource|ReadableInterface $source
     * @param int $offset
     * @return iterable|\Generator|TokenInterface[]
     * @throws SyntaxErrorException
     * @throws \Throwable
     */
    public function lex($source, int $offset = 0): iterable
    {
        $source = File::new($source);

        try {
            yield from $this->lexer->lex($source, $offset);
        } catch (LexerRuntimeExceptionInterface $e) {
            throw new SyntaxErrorException($e->getMessage(), $source, $e->getToken()->getOffset());
        } catch (\Exception $e) {
            throw new SyntaxErrorException($e->getMessage(), $source, $offset);
        }
    }
}

