{% include "partials/header.twig" %}
namespace Railt\SDL;

use Phplrt\Source\File;
use Railt\SDL\Ast\Node;
use Railt\SDL\Ast\Location;
use Railt\SDL\Parser\Lexer;
use Psr\Log\LoggerInterface;
use Railt\SDL\Parser\Builder;
use Phplrt\Parser\Rule\RuleInterface;
use Railt\SDL\Parser\ParserLoggerTrait;
use Phplrt\Parser\Parser as BaseParser;
use Phplrt\Parser\Buffer\BufferInterface;
use Phplrt\Contracts\Source\ReadableInterface;
use Railt\SDL\Exception\SyntaxErrorException;
use Phplrt\Parser\Exception\ParserRuntimeException;
use Phplrt\Parser\Rule\{Lexeme, Optional, Repetition, Alternation, Concatenation};

/**
 * This class is generated by railt/parser, specifically
 * by Railt\SDL\Parser\Generator\Generator.
 */
final class Parser extends BaseParser
{
    use ParserLoggerTrait;

    /**
     * @var string
     */
    private const ROOT_PRODUCTION = 'Document';

    /**
     * Parser constructor.
     *
     * @param LoggerInterface|null $logger
     */
    public function __construct(LoggerInterface $logger = null)
    {
        $this->logger = $logger;

        parent::__construct(new Lexer(), $this->grammar(), [
            parent::CONFIG_AST_BUILDER  => new Builder(),
            parent::CONFIG_INITIAL_RULE => self::ROOT_PRODUCTION,
        ]);
    }

    /**
     * @return array|RuleInterface[]
     */
    private function grammar(): array
    {
        return [
{% for state, rule in rules %}
            {{ value(state) | raw }} => new {{ class(rule, true) }}(
{% for argument in rule.getConstructorArguments() %}
                {{ value(argument, false) | raw }},
{% endfor %}
            ),
{% endfor %}
        ];
    }

    /**
     * {@inheritDoc}
     */
    protected function next(ReadableInterface $source, BufferInterface $buffer, $state)
    {
        $this->depthIn($state, $buffer->current());

        $from = $buffer->current()->getOffset();

        $result = parent::next($source, $buffer, $state);

        if ($result instanceof Node) {
            $result->loc = new Location($source, $from, $buffer->current()->getOffset());
        }

        $this->depthOut($state, $result);

        return $result;
    }

    /**
     * {@inheritDoc}
     */
    public function parse($source): iterable
    {
        $source = File::new($source);
        $this->prepare($source);

        try {
            return parent::parse($source);
        } catch (ParserRuntimeException $e) {
            throw new SyntaxErrorException($e->getMessage(), $source, $e->getToken()->getOffset());
        }
    }
}
